# @pathname: /etc/profile.d/sh.local # automatically sourced *last* by /etc/profile

# function template:
# about tmpl
# tmpl() { ... }


#  src.for function returns ${pathname}:${line}, suitable for emacs
src.for() {
  local _f=${1?:'expecting a function name'}
  local -a _parts=( $( shopt -s extdebug; declare -F ${_f} ) )
  echo ${_parts[2]}:${_parts[3]}
}

# return the pathname where function $1 is defined
f.pathname() ( shopt -s extdebug; declare -F ${1:?'expecting a function name'} | cut -d' ' -f3 ; ); declare -fx f.pathname

export VISUAL=emacs

# history
export HISTSIZE=10000
export HISTFILESIZE=$(( 10 * HISTSIZE ))
shopt -s histappend
export HISTCONTROL=$HISTCONTROL:ignorespace:ignoredups

uhave() { type -p $1 &> /dev/null; }
declare -fx uhave

function on_path? { /usr/bin/which ${1:?'expecting an exec path'} >& /dev/null; }
declare -fx on_path?

home() ( getent passwd ${1:-$USER} | cut -d: -f6; ); declare -fx home
here() ( printf $(realpath -Ls $(dirname ${BASH_SOURCE[${1:-1}]})); ); declare -fx here


# INSTALL=1 source /etc/profile.d/fns.sh # to install all prerequisites
# decl() {
#     declare -fx ${1:?'expecting a declared function name'} ; shift
#     (( $# )) || return 0
#     [[ -z "${INSTALL}" ]] || dnf install -y $@ &> /dev/null || true
# }
# decl decl

# taken from /etc/profile because it's later unset and useful.
path.add() {
    case ":${PATH}:" in
        *:"$1":*)
            ;;
        *)
            if [ "$2" = "after" ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
}
declare -fx path.add

profile.d() {
    for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do
	if [ -r "$i" ]; then
	    . "$i" && echo "$i => $?"
	fi
    done
}
declare -fx profile.d


# only if python is on the path
if uhave python; then
    # have python print out it's absolute pathname. then you don't have to chase symlinks
    python.path() { ${1:-python} -c 'import sys; print(sys.executable)'; }
    declare -fx python.path
fi



# Set window or tab title in shell, useful for organization.
# Note, a different way to set the running title is 'export TITLE="${somethings}".
_title() {
  if [[ -z "$1" ]] ; then
    if [[ -z "${TITLE}" ]]; then
        printf "\e]0;%s %s\a" "${USER}" "${PWD}"
    else
        printf "\e]0;%s\a" "${TITLE}"
    fi	
  else
    printf "\e]0;%s\a" "$*"
  fi
}
declare -fx _title


dnf.src() {
  : "${FUNCNAME[0]} \${src.rpm} [\${destination_dir:-$PWD/src.rpm}] # extract source rpm to an (optional) destination directory"
  local _src_rpm=${1:?'expecting a package or .src.rpm file'}
  local _file_src_rpm=''
  [[ -r ${_src_rpm} ]] && _file_src_rpm=$(file --brief ${_src_rpm} | cut -f1 -d' ') # RPM

  # if the .src.rpm isn't local...
  if [[ "${_file_src_rpm}" != RPM ]] ; then
    # ... then fetch it first.
    _src_rpm=${_src_rpm%.src.rpm}
    local _destdir=/tmp/${FUNCNAME[0]}
    dnf download --source --destdir ${_destdir} ${_src_rpm} || return 1
    _src_rpm=${_destdir}/$(dnf repoquery --qf "%{SOURCERPM}" ${_src_rpm})
  fi
  _destdir=${2:-${PWD}/${_src_rpm%.rpm}} # where to extract the .src.rpm
  _src_rpm=$(realpath ${_src_rpm})
  ( rpm2cpio ${_src_rpm} | 2>/dev/null cpio -idm -D ${_destdir} ) && >&2 ${_src_rpm} extracted to ${_destdir}
}
declare -fx dnf.src


# dnf and decl must come first
dnf() {
    sudo dnf $*
}
# https://unix.stackexchange.com/questions/403181/how-to-pin-a-package-in-dnf-fedora
declare -fx dnf # dnf install 'dnf-command(versionlock)'

dnf.files() {
    command dnf repoquery --installed -l $1
}
declare -fx dnf.files

# lock the kernel to a specific version. update in a more controlled way.
dnf.lock-kernel() {
    local _v=${1:-$(uname -r)}
    sudo dnf versionlock kernel-${_v} kernel-{core,modules,devel,tools,abi-stablelists}-${_v}
}
declare -fx dnf.local-kernel

ac() {
    : "create an asciinema cast, play it and then upload it if you agree; assumes you have asciinema auth'd already"
    local _self=${FUNCNAME}
    local _cast=${1:-/tmp/${USER}/${_self}/$(uuidgen)}.cast
    local _dir=$(dirname ${_cast})
    local _title=${2:-"${HOSTNAME}:${_cast}"}
    mkdir -p ${_dir} || true
    if asciinema rec --title="${_title}" ${_cast} ; then
	>&2 echo -e "\n\nPlaying ${_cast} ..."
	asciinema play ${_cast}
	>&2 echo -e "Playing ${_cast} ... done\n"

    fi

    read -N 1 -p "upload '${_cast}' to https://asciinema.org/? [y|n]: "
    if [[ "${REPLY^^}" = 'Y' ]] ; then
	local _url=$(asciinema upload ${_cast} | tail -n2)
	>&2 echo -e "\nCreated ${_url} and opening in a web browser\n"
	xdg-open ${_url}
    else
	>&2 echo
    fi
    
}
declare -fx ac # dnf install asciinema util-linux xdg-utils

cast2md() {
    : "convert a cast file into a markdown file to be included in a document."
    local _self=${FUNCNAME}
    local _cast=${1:?'expecting a .cast file'}
    local _md=${2:-$1.md}
    printf '```%s\n' ${SHELL##*/} > ${_md}
    asciinema cat ${_cast} >> ${_md}
    printf '```\n' >> ${_md}
}
declare -fx cast2md

dmesg() (
    sudo dmesg --human --ctime --decode --color=always "$@"
); declare -fx dmesg

dmesgf() (
    dmesg --follow "$@"
); declare -fx dmesgf

edmesg() (
    dmesg --level emerg,alert,crit,err "$@"
); declare -fx dmesgf


here() ( printf $(realpath -Ls $(dirname ${BASH_SOURCE[${1:-1}]})); ); declare -fx here
herefrom() ( printf "%s:%s" $(realpath -Ls ${BASH_SOURCE[${1:-1}]}) ${BASH_LINENO[${1:-1}]}; ); declare -fx herefrom


# _map f list # apply f to each element in list returning a string of results
# plus1 { printf '%s' (( 1 + $1 )); }
# declare -a _list=( $(_map plus1 1 2 3) )

_map() {
    local _f=$1; shift
    for a in $@; do printf "%s " $(${_f} $a); done 
}
declare -fx _map


pn1() { realpath -Lms ${1:-${PWD}}; }
declare -fx pn1
pn() { _map pn1 $* ; }
declare -fx pn

cb() { wl-copy -n ; }
declare -fx cb
pn2cb() { pn1 $1 | cb ; }
declare -fx pn2cb

where1() { realpath -Lms ${1:-${BASH_SOURCE}}/..; }
declare -fx where1
where() { _map where1 $* ; }
declare -fx where


export -a SRC;
src1() { local _s=$(pn1 $1); [[ -f "${_s}" ]] && source ${_s} && SRC+=${_s} ; }
declare -fx src1

src() {
    : "@usage: src ${_dir} # sources all .sh files in a tree; src ${_file} ..."
    local _ext=sh
    for _a in "$@"; do
	if [[ -d "${_a}" ]] ; then
	    for _f in $(find "${_a}" -name \*.${_ext}); do source ${_f}; done
	else
	    for _f in "$@"; do src1 ${_f}; done
	fi
    done    
}
declare -fx src		      

md() {
    local _d=$(pn1 $1)
    [[ -d "$_d" ]] || mkdir -p ${_d}
    printf "%s" ${_d}
}
declare -fx md

mkcd() {
    local _d=$(md $1); [[ -z "${_d}" ]] || cd -Pe ${_d}
}
declare -fx mkcd

mp() { local _p=$(printf "%s/%s" $(md $1/..) ${1##*/}); printf ${_p}; }
declare -fx mp
mpt() { local _p=$(printf "%s/%s" $(md $1/..) ${1##*/}); touch ${_p}; printf ${_p}; }
declare -fx mpt
mpcd() { cd $(dirname $(mp ${1:?'expecting a pathname'})); }
declare -fx mpcd

error() {
    local -i _status=${1:-1} ; shift || true
    >&2 printf "{\"exec\": $0, \"status\": ${_status}, \"message\": \"$*\"}"
    exit ${_status}
}
declare -fx error

# TODO mcarifio@ciq.co: need a stacktrace here
# on_exit() {
#     local -i _status=$?
#     local _self=${FUNCNAME[0]}

#     # (( ${_status} )) || error ${_status} $*
#     exit ${_status}
# }
# declare -fx on_exit

xwalk() {
    local _top=${1:?'expecting a root directory'} ; shift || true
    local _ext=${1:-sh} ; shift || true
    find -L ${_top} -path \*/enabled.d/\*.${_ext} -type f -executable -exec '{}' $* \;
}
declare -fx xwalk

mkurl() {
    local _self=${FUNCNAME[0]}
    local _url=${1:?'expecting a url'}
    local _pn=${2:?'expecting a pathname'}
    printf "#!/usr/bin/env xdg-open\n%s" ${_url} | install -m 0755 /dev/stdin ${_pn}
}
declare -fx mkurl


# never can remember the entire name
if uhave com.github.johnfactotum.Foliate; then
   foliate() { command com.github.johnfactotum.Foliate $* & }
   # from epel
   # nb: there are snap and flatpak installs as well. they suck.
   declare -fx foliate # dnf install foliate
fi



all-hosts() ( arp $@ | tail -n+2 | cut -c1-25 | sort | uniq; )
declare -fx all-hosts # hping3


# sudo dnf install -y uuid
if uhave sos; then
   sosr() { sudo sos report --batch --case-id="${SUDO_USER}-$(uuidgen)" --description "${FUNCNAME}" $*; }
   declare -fx sosr
fi

# go repl
yaegi() { rlwrap command yaegi $@; }
declare -fx yaegi # rlwrap


# Can't get lazier than this.
if uhave okular; then
   ok() { okular $* & }
   declare -fx ok
fi
   

# pip from the current python directly; coordinate afterwards with asdf and bash
# hack
pipi() { python -m pip install -U $*; asdf reshim python; hash -r; }
declare -fx pipi

# pdf renaming
pdf.creationdate() { pdfinfo "$1" | grep '^CreationDate:'| awk '{print $6}'; }
declare -fx pdf.creationdate # dnf install pdfinfo

pdf.author() {
  local _author=$(pdfinfo "$1" | grep '^Author:' - | awk '{print $3}' -)
  echo ${_author,,}
}
declare -fx pdf.author

pdf.title() {
  local _title=$(pdfinfo "$1" | grep '^Title:' - | cut -c18- )
  if [[ "${_title}" =~ [^[:punct:]]* ]] ; then
    _title=${BASH_REMATCH[0]}
  fi
  _title=${_title,,}
  _title=${_title// /-}
  echo ${_title}
}
declare -fx pdf.title

pdf.add-date() {
  local _date=$(pdf.creationdate $1)
  if [[ -z "${_date}" ]] ; then
    >&2 printf "no creation date found for %s\n" $1
    return 1
  fi
  local _target=${1%%.pdf}-${_date}.pdf
  mv $1 ${_target}
  echo ${_target}
}
declare -fx pdf.add-date

pn.deparen() {
  for f in "$@"; do
    local _f="${f//\(/}"
    _f="${_f//\)/}"
    mv "$f" "${_f}" && printf "%s " "${_f}"
  done  
}
declare -fx pn.deparen

pdf.mv() {
  # if [[ -r "$1" ]]; then
  #   >&2 printf "'%s' not found\n" "$1"
  #   return 1
  # fi
  : pdf.mv ${_src} ${_location} [${_prefix}]
  local _src="$1"
  local _prefix="${2:-$(basename ${_src} .pdf)}"
  local _location="${3:-${PWD}}"
  local _date=$(pdf.creationdate "${_src}")
  if [[ -z "${_date}" ]] ; then
    >&2 printf "no creation date found for %s\n" "${_src}"
    return 1
  fi

  mv -v "${_src}" "$(md ${_location})/${_prefix}-${_date}.pdf"
}
declare -fx pdf.mv


zlib.lastname0() {
  if [[ "$1" =~ [[:space:]]by[[:space:]][a-zA-Z]+[[:space:]]([a-zA-Z]+) ]] ; then
    echo ${BASH_REMATCH[1],,}
  fi
}

# fix later
zlib.lastname() {
  if [[ "$1" =~ ([^[[:space::]]+[[:space:]]([^[[:space:]][[:comma:]]\)]+))[[:space:]]\(z-lib.org\)\.pdf ]] ; then
    echo ${BASH_REMATCH[1],,}
  fi
}


zlib.mv() {
  : 'zlib.mv ${_src} ${_dir} [${_title} [${_lastname}']]
  local _src="$1"
  local _dir=${2:-${PWD}}
  local _title="${3:-$(pdf.title "${_src}")}"
  if [[ -z "${_title}" ]] ; then
    >&2 echo "no title found, please provide one."
    return 1
  fi
  # local _lastname=${4:-$(zlib.lastname "${_src}")}
  local _lastname=${4:-$(pdf.author "${_src}")}

  local _result="${_dir}/${_title}"
  [[ -n "${_lastname}" ]] && _result+="-${_lastname}"
  local _date=$(pdf.creationdate "${_src}")
  [[ -n "${_date}" ]] && _result+="-${_date}"
  mv -v "${_src}" ${_result}.pdf
}

declare -fx zlib.lastname zlib.mv


for c in kind kubectl glab lab; do uhave ${c} && source <(${c} completion bash); done
for c in /usr/share/bash-completion/completions/{docker,dhclient,nmcli,nmap,ip}; do uhave ${c} && source ${c}; done

drmi() { docker rmi -f $(docker images -f "dangling=true" -q); }
declare -fx drmi
# https://docs.docker.com/engine/security/rootless/
systemctl --user is-active docker &> /dev/null && export DOCKER_HOST=unix:///run/user/$(id -u)/docker.sock

# dnf install gcc-toolset-11
# src1 /opt/rh/gcc-toolset-11/enable

gnome-snapshot() {
  mkdir -p ~/Pictures/snapshot &> /dev/null
  local _snapshot==~/Pictures/snapshot/$(uuidgen).png
  command gnome-snapshot --area --file=${_snapshot}
  ln -srf ${_snapshot} ~/Pictures/snapshot/latest.png
  gimp ~/Pictures/snapshot/latest.png
}
declare -fx gnome-snapshot


# packer -autocomplete-install || true
if uhave packer; then
   complete -C /usr/bin/packer packer
fi
   

# oci config
if uhave oci; then
   export OCI_CLI_SUPPRESS_FILE_PERMISSIONS_WARNING=True
   export OCI_CLI_CONFIG_FILE=${HOME}/.config/cloud/oci/config
fi

main() {
    local _action=${1:-start} ; shift || true
    ${_action} $*    
}
declare -fx main

# _history() {
#     history -a
#     history -c
#     history -r
# }
# declare -fx _history

if uhave bcompare; then
   bcompare() { QT_GRAPHICSSYSTEM=native command bcompare "$@"; }
   declare -fx bcompare
fi


if uhave copyq; then
copyq() {
   QT_QPA_PLATFORM=xcb command copyq $*
}
declare -fx copyq
fi


# ssh when ~/.ssh/config.d/hosts.d/${_remote_host}.host.conf isn't around.
ssh.mkpair() {
    : 'ssh.mkpair [${_remote_host:-tbs} [${_remote_user:-${USER}}]] |> create key in ${HOME}/.ssh/keys.d/quad, copy .pub to clipboard'
    local _remote_host="${1:-tbs}"
    local _remote_user="${2:-${USER}}"
    local _keyfile="${HOME}/.ssh/keys.d/quad/${USER}@${HOSTNAME}4${_remote_user}@${_remote_host}_id_rsa"
    local _pub="${_keyfile}.pub"
    local _comment="${HOSTNAME}:${_pub}"
    ssh-keygen -q -N ''   -f "${_keyfile}" -C "${_comment}"
    wl-copy -n < "${_pub}" && >&2 echo "'${_pub}' copied to clipboard"
}

ssh.User() {
    if [[ "$1" =~ ^([^@]*)@ ]] ; then
        echo ${BASH_REMATCH[1]}
    else
        echo ${USER}
    fi
}

ssh.HostName() {
    if [[ "$1" =~ @(.*)$ ]] ; then
        echo ${BASH_REMATCH[1]}
    else
        echo "$1"
    fi
}

ssh.IdentityFile() {
    local _remote_user=$1
    local _remote_host=$2
    local _f=~/.ssh/keys.d/quad/${USER}@${HOSTNAME}4${_remote_user}@${_remote_host}_id_rsa
    [[ -r ${_f} ]] && { echo ${_f}; return 0; }
    local _f=~/.ssh/keys.d/quad/${_remote_user}@${_remote_host}_id_rsa
    [[ -r ${_f} ]] && { echo ${_f}; return 0; }
    local _f=~/.ssh/keys.d/quad/${_remote_host}_id_rsa
    [[ -r ${_f} ]] && { echo ${_f}; return 0; }
}

ssh.ssh() {
    : 'ssh.ssh [${user}@]?${host} $*'
    local _target=${1:?"${FUNCNAME} expecting a host"}; shift
    local _remote_user=$(ssh.User ${_target})
    local _remote_host=$(ssh.HostName ${_target})
    local _IdentityFile=$(ssh.IdentityFile ${_remote_host} ${_remote_user})
    local _options=""
    [[ -n "${_IdentityFile}" ]] && _options+="-o IdentityFile=${_IdentityFile}"
    (set -x; command ssh "$@" "${_options}" ${_target})
}
declare -fx ssh.mkpair ssh.ssh ssh.User ssh.HostName ssh.IdentityFile

mnt.iso() {
    : 'mnt.iso .iso [/optional/mountpoint/prefix] # mount .iso as a loopback device'
    local _iso=${1:?'expecting an iso'}
    local _mountpoint=${2:-/mnt/isofs/$(basename ${_iso} .iso)}
    sudo install -o ${USER} -g ${USER} -d ${_mountpoint}
    sudo mount -o loop ${_iso} ${_mountpoint}
}
declare -fx mnt.iso


# a better whois, note the spelling
whois.browse() (
    local _name=${1:?'expecting a domain name, e.g. carif.io'}
    if whois ${_name} &> /dev/null; then
        >&2 echo "${_name} registered."
        xdg-open http://www.${_name}/
    else
        echo "${_name} available."
    fi	
); declare -fx whois.browse

ec() (
   # if the emacs daemon isn't running, start the service
   local _service=emacs-modified
   if ! systemctl --user --quiet is-active ${_service} ; then
      systemctl --user start ${_service}
      >&2 echo "Starting emacs-modified service which includes a 10s wait."
      return 1
   fi      

   # how many client frames are there?
   declare -i _frames=$(emacsclient -e '(length (frame-list))')

   # command defaults when there's a frame showing
   local _c='' _default='.'

   # if no frames are showing
   if [[ ${_frames} -eq 1 ]] ; then
     # create a new one
     _c='-c'
   fi     
   emacsclient ${_c} "${@:-${_default}}" &
); declare -fx ec

export EDITOR='emacsclient -t'
export VISUAL='emacsclient -t'
alias vi='emacsclient -t'
alias vim='emacsclient -t'




# TODO error unless theirs' only one
git.repopath() { dirname $(find ${_here} -name .git -type d -minpath 2 -maxpath 2); }
declare -fx git.repopath

# Hack the prompt command, don't use functions since they don't see to be exported?
# Don't keep extending the PROMPT_COMMAND by sourcing scripts.

if ! type -t _direnv_hook &> /dev/null ; then
  source <(direnv hook bash)
  declare -fx _direnv_hook
fi

export PROMPT_SUFFIX="${PROMPT_SUFFIX:-${PROMPT_COMMAND}}"
if [[ "${PROMPT_SUFFIX}" = $"__vte_prompt_command"* ]] ; then
  if type -t __vte_prompt_command &>/dev/null ; then
    function __vte_prompt_command { : ; }
  fi
  declare -fx __vte_prompt_command __vte_osc7
fi
  
  
export PROMPT_COMMAND="${PROMPT_SUFFIX}"
# printf "PROMPT_SUFFIX: '%s'\n" "${PROMPT_SUFFIX}"
# history is added to PROMPT_COMMAND somewhere else. I can't figure out where. gcc-toolkit-11 contributes somehow.
if [[ -z "${PROMPT_COMMAND}" ]]; then
  export PROMPT_COMMAND='history -a; history -c; history -r'
elif [[ "${PROMPT_COMMAND}" != *"history -a;"* ]] ; then
  export PROMPT_COMMAND+='; history -a; history -c; history -r'
fi



# Only update tab/window title if your terminal supports it.
[[ linux != "${TERM}" && "${PROMPT_COMMAND}" != *"\e]0;%s\a"* ]] && export PROMPT_COMMAND+='; printf "\e]0;%s\a" "${TITLE:-${USER}@${HOSTNAME}:${PWD}}"'

( shopt -s nullglob; for f in ~/.local/bash_completion.d/*; do source ${f}; done )

profile.d() {
  : 'profile.d ${dir}... # treat each ${dir} as a profile directory like /etc/profile.d'
  local -a _roots=( "${@:-\"~/.${FUNCNAME}\"}" )
  for _d in "${_roots[@]}"; do
      for _f in "${_d}/*.sh"; do source "${_f}"; done
      local _sh_local="${_d}/sh.local"
      [[ -r  "${_sh_local}" ]] && source "${_sh_local}"
  done
}
